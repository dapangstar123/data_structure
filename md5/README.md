# MD5算法解析

MD5是一个安全的散列算法，输入两个不同的明文不会得到相同的输出值，根据输出值，不能得到原始的明文，即其过程不可逆；所以要解密MD5没有现成的算法，只能用穷举法，把可能出现的明文，用MD5算法散列之后，把得到的散列值和原始的数据形成一个一对一的映射表，通过比在表中比破解密码的MD5算法散列值，通过匹配从映射表中找出破解密码所对应的原始明文


**1.待加密信息处理**

显而易见，我们要对一个字符串进行MD5计算，那么肯定要从这个字符串的处理入手。我们知道一个字符的长度是一个字节，即8位（bit）的长度。MD5对待加密的字符串的处理是将一个字符串分割成每512位为一个分组，形如N*512+R，这里的R是余下的位数。这个R分为几种情况：

R=0时，需要补位，单补上一个512位的分组，因为还要加入最后64个位的字符串长度。

R<448时，则需要补位到448位，后面添加64位的字符串长度。

R>448时，除了补满这一分组外，还要再补上一个512位的分组后面添加64位的字符串长度。

补位的形式是先填充一个1，再接无数个0，直到补足512位。

**2.MD5的链接变量及基本操作**

MD5有四个32位的被称作链接变量的整数参数，这是个参数我们定义为A、B、C、D其取值为：A=0x01234567，B=0x89abcdef，C=0xfedcba98，D=0x76543210。但考虑到内存数据存储大小端的问题我们将其赋值为：A=0x67452301，B=0xefcdab89，C=0x98badcfe，D=0x10325476。

同时MD5算法规定了四个非线性操作函数（&是与，|是或，~是非，^是异或）：

F(X,Y,Z) =(X&Y)|((~X)&Z)

G(X,Y,Z) =(X&Z)|(Y&(~Z))

H(X,Y,Z) =X^Y^Z

I(X,Y,Z)=Y^(X|(~Z))

这些函数是这样设计的：如果X、Y和Z的对应位是独立和均匀的，那么结果的每一位也应是独立和均匀的。

利用上面的四种操作，生成四个重要的计算函数。首先我们声明四个中间变量a,b,c,d，赋值：a = A, b = B, c = C, d = D。然后定义这四个计算函数为：

FF(a, b, c, d, M[j], s, ti)表示 a = b + ((a + F(b, c, d) + Mj + ti) <<< s)

GG(a, b, c, d, M[j], s, ti)表示 a = b + ((a + G(b, c, d) + Mj + ti) <<< s)

HH(a, b, c, d, M[j], s, ti)表示 a = b + ((a + H(b, c, d) + Mj + ti) <<< s)

II(a, b, c, d, M[j], s, ti)表示 a = b + ((a + I(b, c, d) + Mj + ti) <<< s)

其中M[j]表示消息的第j个子分组（从0到15），<<表示循环左移s，常数ti是4294967296*abs(sin(i))的整数部分，i取值从1到64，单位是弧度。

**3.循环计算**

定义好上述的四个计算函数后，就可以实现MD5的真正循环计算了。这个循环的循环次数为512位分组的个数。每次循环执行64不计算，上述4个函数每个16次，具体如下：

        //第一轮循环计算

        FF(a,b,c,d,M[0],7,0xd76aa478);

        FF(d,a,b,c,M[1],12,0xe8c7b756);

        FF(c,d,a,b,M[2],17,0x242070db);

        FF(b,c,d,a,M[3],22,0xc1bdceee);

        FF(a,b,c,d,M[4],7,0xf57c0faf);

        FF(d,a,b,c,M[5],12,0x4787c62a);

        FF(c,d,a,b,M[6],17,0xa8304613);

        FF(b,c,d,a,M[7],22,0xfd469501) ;

        FF(a,b,c,d,M[8],7,0x698098d8) ;

        FF(d,a,b,c,M[9],12,0x8b44f7af) ;

        FF(c,d,a,b,M[10],17,0xffff5bb1) ;

        FF(b,c,d,a,M[11],22,0x895cd7be) ;

        FF(a,b,c,d,M[12],7,0x6b901122) ;

        FF(d,a,b,c,M[13],12,0xfd987193) ;

        FF(c,d,a,b,M[14],17,0xa679438e) ;

        FF(b,c,d,a,M[15],22,0x49b40821);

 

        //第二轮循环计算

        GG(a,b,c,d,M[1],5,0xf61e2562);

        GG(d,a,b,c,M[6],9,0xc040b340);

        GG(c,d,a,b,M[11],14,0x265e5a51);

        GG(b,c,d,a,M[0],20,0xe9b6c7aa) ;

        GG(a,b,c,d,M[5],5,0xd62f105d) ;

        GG(d,a,b,c,M[10],9,0x02441453) ;

        GG(c,d,a,b,M[15],14,0xd8a1e681);

        GG(b,c,d,a,M[4],20,0xe7d3fbc8) ;

        GG(a,b,c,d,M[9],5,0x21e1cde6) ;

        GG(d,a,b,c,M[14],9,0xc33707d6) ;

        GG(c,d,a,b,M[3],14,0xf4d50d87) ;

        GG(b,c,d,a,M[8],20,0x455a14ed);

        GG(a,b,c,d,M[13],5,0xa9e3e905);

        GG(d,a,b,c,M[2],9,0xfcefa3f8) ;

        GG(c,d,a,b,M[7],14,0x676f02d9) ;

        GG(b,c,d,a,M[12],20,0x8d2a4c8a);

 

        //第三轮循环计算

        HH(a,b,c,d,M[5],4,0xfffa3942);

        HH(d,a,b,c,M[8],11,0x8771f681);

        HH(c,d,a,b,M[11],16,0x6d9d6122);

        HH(b,c,d,a,M[14],23,0xfde5380c) ;

        HH(a,b,c,d,M[1],4,0xa4beea44) ;

        HH(d,a,b,c,M[4],11,0x4bdecfa9) ;

        HH(c,d,a,b,M[7],16,0xf6bb4b60) ;

        HH(b,c,d,a,M[10],23,0xbebfbc70);

        HH(a,b,c,d,M[13],4,0x289b7ec6);

        HH(d,a,b,c,M[0],11,0xeaa127fa);

        HH(c,d,a,b,M[3],16,0xd4ef3085);

        HH(b,c,d,a,M[6],23,0x04881d05);

        HH(a,b,c,d,M[9],4,0xd9d4d039);

        HH(d,a,b,c,M[12],11,0xe6db99e5);

        HH(c,d,a,b,M[15],16,0x1fa27cf8) ;

        HH(b,c,d,a,M[2],23,0xc4ac5665);

   

        //第四轮循环计算

        II(a,b,c,d,M[0],6,0xf4292244) ;

        II(d,a,b,c,M[7],10,0x432aff97) ;

        II(c,d,a,b,M[14],15,0xab9423a7);

        II(b,c,d,a,M[5],21,0xfc93a039) ;

        II(a,b,c,d,M[12],6,0x655b59c3) ;

        II(d,a,b,c,M[3],10,0x8f0ccc92) ;

        II(c,d,a,b,M[10],15,0xffeff47d);

        II(b,c,d,a,M[1],21,0x85845dd1) ;

        II(a,b,c,d,M[8],6,0x6fa87e4f) ;

        II(d,a,b,c,M[15],10,0xfe2ce6e0);

        II(c,d,a,b,M[6],15,0xa3014314) ;

        II(b,c,d,a,M[13],21,0x4e0811a1);

        II(a,b,c,d,M[4],6,0xf7537e82) ;

        II(d,a,b,c,M[11],10,0xbd3af235);

        II(c,d,a,b,M[2],15,0x2ad7d2bb);

        II(b,c,d,a,M[9],21,0xeb86d391);
  
**4.结果输出**

处理完所有的512位的分组后，得到一组新的A,B,C,D的值，将这些值按ABCD的顺序级联，就得到了想要的MD5散列值。当然，输出依然要考虑内存存储的大小端问题。

****
参考：

  百度百科；
  
  博客园：https://www.cnblogs.com/foxclever/p/7668369.html
